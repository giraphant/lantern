"""
‰∫§ÊòìÊâßË°åÂô® - Ë¥üË¥£Ë∞ÉÁî®exchangeÂÆ¢Êà∑Á´ØÊâßË°å‰∫§Êòì„ÄÇ

ËÅåË¥£Ôºö
1. Ë∞ÉÁî®Exchange AÂíåExchange BÁöÑÂÆ¢Êà∑Á´ØÊñπÊ≥ï
2. Á≠âÂæÖËÆ¢ÂçïÊàê‰∫§
3. ËøîÂõûÊâßË°åÁªìÊûú
4. ‰∏çÂåÖÂê´‰∏öÂä°ÈÄªËæëÂà§Êñ≠
"""

import asyncio
import logging
from decimal import Decimal
from typing import NamedTuple, Optional

from hedge.rebalancer import TradeAction
from hedge.safety_checker import PositionState, PendingOrdersInfo


class ExecutionResult(NamedTuple):
    """ÊâßË°åÁªìÊûú"""
    success: bool
    exchange_a_order_id: Optional[str] = None
    exchange_a_price: Optional[Decimal] = None
    exchange_b_order_id: Optional[str] = None
    exchange_b_price: Optional[Decimal] = None
    error: Optional[str] = None


class TradingExecutor:
    """
    ‰∫§ÊòìÊâßË°åÂô®„ÄÇ

    Â∞ÅË£ÖÊâÄÊúâ‰∏é‰∫§ÊòìÊâÄÁöÑ‰∫§‰∫íÔºå‰ΩÜ‰∏çÂåÖÂê´‰∏öÂä°ÈÄªËæë„ÄÇ
    """

    def __init__(self, exchange_a_client, exchange_b_client, logger=None):
        """
        ÂàùÂßãÂåñÊâßË°åÂô®„ÄÇ

        Args:
            exchange_a_client: ‰∫§ÊòìÊâÄAÂÆ¢Êà∑Á´Ø (‰∏ª‰∫§ÊòìÊâÄÔºå‰ΩøÁî®ÂÅöÂ∏ÇÂçï)
            exchange_b_client: ‰∫§ÊòìÊâÄBÂÆ¢Êà∑Á´Ø (ÂØπÂÜ≤‰∫§ÊòìÊâÄÔºå‰ΩøÁî®Â∏Ç‰ª∑Âçï)
            logger: Êó•ÂøóËÆ∞ÂΩïÂô®
        """
        self.exchange_a = exchange_a_client
        self.exchange_b = exchange_b_client
        self.logger = logger or logging.getLogger(__name__)

        # Ëé∑Âèñ‰∫§ÊòìÊâÄÂêçÁß∞Áî®‰∫éÊó•Âøó
        self.exchange_a_name = exchange_a_client.get_exchange_name().upper()
        self.exchange_b_name = exchange_b_client.get_exchange_name().upper()

    async def get_positions(self) -> PositionState:
        """
        ‰ªé‰∫§ÊòìÊâÄËé∑ÂèñÂΩìÂâçÁúüÂÆû‰ªì‰Ωç„ÄÇ

        Returns:
            PositionState
        """
        exchange_a_pos = await self.exchange_a.get_account_positions()
        exchange_b_pos = await self.exchange_b.get_account_positions()

        return PositionState(
            exchange_a_position=exchange_a_pos,
            exchange_b_position=exchange_b_pos
        )

    async def get_pending_orders(self) -> PendingOrdersInfo:
        """
        ‰ªé‰∫§ÊòìÊâÄËé∑ÂèñÊú™Êàê‰∫§ËÆ¢ÂçïÊï∞Èáè„ÄÇ

        Returns:
            PendingOrdersInfo
        """
        try:
            # Ëé∑ÂèñGRVTÊú™Êàê‰∫§ËÆ¢Âçï
            exchange_a_orders = await self.exchange_a.get_active_orders(
                contract_id=self.exchange_a.config.contract_id
            )
            exchange_a_pending_count = len(exchange_a_orders)
        except Exception as e:
            self.logger.error(f"Failed to get Exchange A pending orders: {e}")
            exchange_a_pending_count = 0

        try:
            # Ëé∑ÂèñLighterÊú™Êàê‰∫§ËÆ¢Âçï
            exchange_b_orders = await self.exchange_b.get_active_orders(
                contract_id=self.exchange_b.config.contract_id
            )
            exchange_b_pending_count = len(exchange_b_orders)
        except Exception as e:
            self.logger.error(f"Failed to get Exchange B pending orders: {e}")
            exchange_b_pending_count = 0

        return PendingOrdersInfo(
            exchange_a_pending_count=exchange_a_pending_count,
            exchange_b_pending_count=exchange_b_pending_count
        )

    async def execute_trade(
        self,
        action: TradeAction,
        quantity: Decimal,
        wait_for_fill: bool = True,
        fill_timeout: int = 30
    ) -> ExecutionResult:
        """
        ÊâßË°å‰∫§ÊòìÊåá‰ª§„ÄÇ

        Args:
            action: ‰∫§ÊòìÂä®‰Ωú
            quantity: ‰∫§ÊòìÊï∞Èáè
            wait_for_fill: ÊòØÂê¶Á≠âÂæÖGRVTËÆ¢ÂçïÊàê‰∫§
            fill_timeout: Á≠âÂæÖÊàê‰∫§ÁöÑË∂ÖÊó∂Êó∂Èó¥ÔºàÁßíÔºâ

        Returns:
            ExecutionResult
        """
        self.logger.info(f"üîß Executing action: {action.value}")

        if action == TradeAction.HOLD:
            return ExecutionResult(success=True)

        if action == TradeAction.BUILD_LONG:
            return await self._execute_build_long(quantity, wait_for_fill, fill_timeout)

        if action == TradeAction.CLOSE_LONG:
            return await self._execute_close_long(quantity, wait_for_fill, fill_timeout)

        if action == TradeAction.BUILD_SHORT:
            return await self._execute_build_short(quantity, wait_for_fill, fill_timeout)

        if action == TradeAction.CLOSE_SHORT:
            return await self._execute_close_short(quantity, wait_for_fill, fill_timeout)

        return ExecutionResult(success=False, error=f"Unknown action: {action}")

    async def _execute_build_long(
        self, quantity: Decimal, wait_for_fill: bool, timeout: int
    ) -> ExecutionResult:
        """
        Âª∫Â§ö‰ªìÔºöGRVT‰π∞ÂÖ• + LighterÂçñÂá∫„ÄÇ
        """
        try:
            # 1. GRVT‰π∞ÂÖ•ÔºàÂÅöÂ∏ÇÂçïÔºâ
            self.logger.info(f"Placing Exchange A buy order: {quantity}")
            exchange_a_result = await self.exchange_a.place_open_order(
                contract_id=self.exchange_a.config.contract_id,
                quantity=quantity,
                direction="buy"
            )

            if not exchange_a_result.success:
                return ExecutionResult(
                    success=False,
                    error=f"Exchange A order failed: {exchange_a_result.error_message}"
                )

            self.logger.info(f"‚úì Exchange A buy order placed: {exchange_a_result.order_id} @ {exchange_a_result.price}")

            # 2. Á≠âÂæÖGRVTËÆ¢ÂçïÊàê‰∫§
            if wait_for_fill:
                self.logger.info("Waiting for Exchange A order to fill...")
                filled = await self._wait_for_fill(exchange_a_result.order_id, timeout)

                if not filled:
                    self.logger.warning("Exchange A order not filled, cancelling...")
                    await self.exchange_a.cancel_order(exchange_a_result.order_id)
                    return ExecutionResult(
                        success=False,
                        error="Exchange A order not filled within timeout"
                    )

                self.logger.info("‚úì Exchange A order filled")

            # 3. LighterÂçñÂá∫ÔºàÂØπÂÜ≤Ôºâ
            self.logger.info(f"Placing Exchange B sell order: {quantity}")
            exchange_b_result = await self.exchange_b.place_open_order(
                contract_id=self.exchange_b.config.contract_id,
                quantity=quantity,
                direction="sell"
            )

            if not exchange_b_result.success:
                return ExecutionResult(
                    success=False,
                    grvt_order_id=exchange_a_result.order_id,
                    grvt_price=exchange_a_result.price,
                    error=f"Exchange B order failed: {exchange_b_result.error_message}"
                )

            self.logger.info(f"‚úì Exchange B sell order placed @ {exchange_b_result.price}")

            return ExecutionResult(
                success=True,
                grvt_order_id=exchange_a_result.order_id,
                grvt_price=exchange_a_result.price,
                lighter_order_id=exchange_b_result.order_id,
                lighter_price=exchange_b_result.price
            )

        except Exception as e:
            self.logger.error(f"Error executing build long: {e}")
            return ExecutionResult(success=False, error=str(e))

    async def _execute_close_long(
        self, quantity: Decimal, wait_for_fill: bool, timeout: int
    ) -> ExecutionResult:
        """
        Âπ≥Â§ö‰ªìÔºöGRVTÂçñÂá∫ + Lighter‰π∞ÂÖ•„ÄÇ
        """
        try:
            # 1. GRVTÂçñÂá∫ÔºàÂÅöÂ∏ÇÂçïÔºâ
            self.logger.info(f"Placing Exchange A sell order: {quantity}")
            exchange_a_result = await self.exchange_a.place_open_order(
                contract_id=self.exchange_a.config.contract_id,
                quantity=quantity,
                direction="sell"
            )

            if not exchange_a_result.success:
                return ExecutionResult(
                    success=False,
                    error=f"Exchange A order failed: {exchange_a_result.error_message}"
                )

            self.logger.info(f"‚úì Exchange A sell order placed: {exchange_a_result.order_id} @ {exchange_a_result.price}")

            # 2. Á≠âÂæÖÊàê‰∫§
            if wait_for_fill:
                self.logger.info("Waiting for Exchange A order to fill...")
                filled = await self._wait_for_fill(exchange_a_result.order_id, timeout)

                if not filled:
                    self.logger.warning("Exchange A order not filled, cancelling...")
                    await self.exchange_a.cancel_order(exchange_a_result.order_id)
                    return ExecutionResult(
                        success=False,
                        error="Exchange A order not filled within timeout"
                    )

                self.logger.info("‚úì Exchange A order filled")

            # 3. Lighter‰π∞ÂÖ•ÔºàÂØπÂÜ≤Ôºâ
            self.logger.info(f"Placing Exchange B buy order: {quantity}")
            exchange_b_result = await self.exchange_b.place_open_order(
                contract_id=self.exchange_b.config.contract_id,
                quantity=quantity,
                direction="buy"
            )

            if not exchange_b_result.success:
                return ExecutionResult(
                    success=False,
                    grvt_order_id=exchange_a_result.order_id,
                    grvt_price=exchange_a_result.price,
                    error=f"Exchange B order failed: {exchange_b_result.error_message}"
                )

            self.logger.info(f"‚úì Exchange B buy order placed @ {exchange_b_result.price}")

            return ExecutionResult(
                success=True,
                grvt_order_id=exchange_a_result.order_id,
                grvt_price=exchange_a_result.price,
                lighter_order_id=exchange_b_result.order_id,
                lighter_price=exchange_b_result.price
            )

        except Exception as e:
            self.logger.error(f"Error executing close long: {e}")
            return ExecutionResult(success=False, error=str(e))

    async def _execute_build_short(
        self, quantity: Decimal, wait_for_fill: bool, timeout: int
    ) -> ExecutionResult:
        """
        Rebalance‰∏ìÁî®ÔºöLighterÂçñÂá∫ÔºàÂ∏Ç‰ª∑ÂçïÁ´ãÂç≥Êàê‰∫§Ôºâ„ÄÇ
        Áî®‰∫éÂáèÂ∞ëLighterÁ©∫Â§¥‰ªì‰ΩçÔºåÂ¢ûÂä†ÂáÄÂ§öÂ§¥„ÄÇ
        """
        try:
            self.logger.info(f"Rebalancing: Lighter sell {quantity}")
            exchange_b_result = await self.exchange_b.place_open_order(
                contract_id=self.exchange_b.config.contract_id,
                quantity=quantity,
                direction="sell"
            )

            if not exchange_b_result.success:
                return ExecutionResult(
                    success=False,
                    error=f"Exchange B rebalance sell failed: {exchange_b_result.error_message}"
                )

            self.logger.info(f"‚úì Lighter rebalance sell @ {exchange_b_result.price}")

            return ExecutionResult(
                success=True,
                lighter_order_id=exchange_b_result.order_id,
                lighter_price=exchange_b_result.price
            )

        except Exception as e:
            self.logger.error(f"Error executing rebalance sell: {e}")
            return ExecutionResult(success=False, error=str(e))

    async def _execute_close_short(
        self, quantity: Decimal, wait_for_fill: bool, timeout: int
    ) -> ExecutionResult:
        """
        Rebalance‰∏ìÁî®ÔºöLighter‰π∞ÂÖ•ÔºàÂ∏Ç‰ª∑ÂçïÁ´ãÂç≥Êàê‰∫§Ôºâ„ÄÇ
        Áî®‰∫éÂ¢ûÂä†LighterÁ©∫Â§¥‰ªì‰ΩçÔºåÂáèÂ∞ëÂáÄÂ§öÂ§¥„ÄÇ
        """
        try:
            self.logger.info(f"Rebalancing: Lighter buy {quantity}")
            exchange_b_result = await self.exchange_b.place_open_order(
                contract_id=self.exchange_b.config.contract_id,
                quantity=quantity,
                direction="buy"
            )

            if not exchange_b_result.success:
                return ExecutionResult(
                    success=False,
                    error=f"Exchange B rebalance buy failed: {exchange_b_result.error_message}"
                )

            self.logger.info(f"‚úì Lighter rebalance buy @ {exchange_b_result.price}")

            return ExecutionResult(
                success=True,
                lighter_order_id=exchange_b_result.order_id,
                lighter_price=exchange_b_result.price
            )

        except Exception as e:
            self.logger.error(f"Error executing rebalance buy: {e}")
            return ExecutionResult(success=False, error=str(e))

    async def _wait_for_fill(self, order_id: str, timeout: int) -> bool:
        """
        Á≠âÂæÖGRVTËÆ¢ÂçïÊàê‰∫§„ÄÇ

        Args:
            order_id: ËÆ¢ÂçïID
            timeout: Ë∂ÖÊó∂Êó∂Èó¥ÔºàÁßíÔºâ

        Returns:
            bool: ÊòØÂê¶Êàê‰∫§
        """
        import time
        start = time.time()

        while time.time() - start < timeout:
            try:
                order_info = await self.exchange_a.get_order_info(order_id=order_id)

                if order_info and order_info.status == 'FILLED':
                    return True

                if order_info and order_info.status in ['CANCELLED', 'REJECTED']:
                    return False

                await asyncio.sleep(0.5)

            except Exception as e:
                self.logger.debug(f"Error checking order status: {e}")
                await asyncio.sleep(1)

        return False

    async def cancel_all_orders(self):
        """ÂèñÊ∂àÊâÄÊúâÊú™Êàê‰∫§ËÆ¢Âçï"""
        try:
            self.logger.info("Cancelling all orders...")
            await self.exchange_a.cancel_all_orders()
            await self.exchange_b.cancel_all_orders()
            self.logger.info("‚úì All orders cancelled")
        except Exception as e:
            self.logger.error(f"Error cancelling orders: {e}")
